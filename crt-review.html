<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="crt-review-display.html">

<dom-module id="crt-review">
  <template>
    <iron-ajax
      auto
      params="{{params}}"
      url="https://codereview.chromium.org/api/{{issue}}"
      on-response="handleResponse"></iron-ajax>
    <crt-review-display data={{data}}></crt-review-display>
  </template>
<script>

var Other = "other";
var WaitingForReview = "waiting for review";
var WaitingForAuthor = "waiting for author";
var WaitingForBots = "waiting for bots";
var NotWaiting = "not waiting";


var ChangedReviewers = "changed reviewers";
var CQBitChecked = "CQ bit checked";
var CQBitUnchecked = "CQ bit unchecked";
var ResponseToComments = "Response to comments";
var Committed = "Committed";

Polymer({
  is: 'crt-review',

  properties: {
    params: { type: Object, value: function() { return { messages: true } } },
    issue: Number,
    data: { type: Object , value: function() { return { } } }
  },
  
  handleResponse: function(e) {
    this.set("data", this.summarize(e.detail.response));
  },

  summarize: function(data) {
    data = JSON.parse(JSON.stringify(data));
    var d = Date.parse(data.created);

    // process dates into deltas
    for (var message of data.messages) {
      var e = Date.parse(message.date);
      message.delta = e - d;
      d = e;
    }

    // summarize autogenerated messages, and messages from commit-bot
    for (var message of data.messages) {
      if (message.auto_generated == true || message.sender == 'commit-bot@chromium.org') {
        if (/Description was changed/.exec(message.text))
          message.summary = "Description was changed";
        else if (/changed reviewers/.exec(message.text)) {
          message.type = ChangedReviewers;
          message.summary = message.text.split('\n').slice(1).join('\n');
        }
        else if (/The CQ bit/.exec(message.text)) {
          message.summary = message.text;
          if (/The CQ bit was checked/.exec(message.text)) {
            message.type = CQBitChecked;
          } else {
            message.type = CQBitUnchecked;
          }
          console.log(message.type);
        }
        else if (/Dry run/.exec(message.text))
          message.summary = message.text;
        else if (/The patchset/.exec(message.text))
          message.summary = message.text;
        else if (message.sender == 'commit-bot@chromium.org') {
          message.summary = message.text;
          message.auto_generated = true;
          if (message.text.includes("Committed patchset")) {
            message.type = Committed;
          }
        }
      } else {
        if (message.text.includes(data.issue))
          message.type = ResponseToComments;
      }
    }

    // set effective reviewers
    var reviewers = [];
    var lgtm = [];
    for (var message of data.messages) {
      if (message.type == ChangedReviewers) {
        reviewers = reviewers.slice();
        var delta = message.summary.split(/[\s,]+/);
        var adding = true;
        for (var item of delta) {
          if (item == '+')
            adding = true;
          else if (item == '-')
            adding = false;
          else if (adding)
            reviewers.push(item)
          else
            reviewers.splice(reviewers.indexOf(item), 1);
        }
      }
      message.reviewers = reviewers;

      if (message.approval && !lgtm.includes(message.sender)) {
        lgtm = lgtm.slice();
        lgtm.push(message.sender);
        if (!reviewers.includes(message.sender)) {
          reviewers = reviewers.slice();
          reviewers.push(message.sender);
          message.reviewers = reviewers;
        }
      }
      message.lgtm = lgtm;

      message.all_lgtm = true;
      for (var reviewer of message.reviewers) {
        if (!lgtm.includes(reviewer))
          message.all_lgtm = false;
      }
      
    }

    // classify messages
    for (var i = 0; i < data.messages.length; i++) {
      var message = data.messages[i];

      if (message.reviewers.length == 0) {
        message.waitClass = Other;
        continue;
      }

      if (message.type == ChangedReviewers) {
        message.waitClass = WaitingForReview;
        continue;
      }

      if (!message.auto_generated && message.reviewers.includes(message.sender)) {
        message.waitClass = WaitingForAuthor;
        continue;
      }

      if (message.type == CQBitChecked) {
        if (message.all_lgtm)
          message.waitClass = WaitingForBots;
        else
          message.waitClass = data.messages[i - 1].waitClass;
        continue;
      } 

      if (message.type == CQBitUnchecked && message.all_lgtm) {
        message.waitClass = WaitingForAuthor;
        continue;
      }

      /*
       * The patch owner sent this message.
       * 
       * Look through subsequent messages that
       * are sent by the sender or are autogenerated.
       * If any of them are responses to review comments
       * then the sender isn't waiting.
       */

      // check returns true if the sender is still reviewing in the future.
      function check(idx) {
        if (idx >= data.messages.length) {
          return false;
        }
        var message = data.messages[idx];
        if (!((message.sender == data.owner_email) || message.auto_generated))
          return false;
        if (message.type == ResponseToComments) {
          i = idx - 1;
          return true;
        }
        var isReviewingInFuture = check(idx + 1);
        if (isReviewingInFuture)
          message.waitClass = WaitingForAuthor;
        return isReviewingInFuture;
      }

      if (message.sender == data.owner_email && !message.auto_generated) {
        if (check(i + 1))
          message.waitClass = WaitingForAuthor;
        else if (message.all_lgtm)
          message.waitClass = WaitingForAuthor;
        else
          message.waitClass = WaitingForReview;
        continue;
      }

      if (message.type == Committed) {
        message.waitClass = NotWaiting;
        var j = i - 1;
        while (j >= 0) {
          data.messages[j].waitClass = WaitingForBots;
          if (data.messages[j--].type == CQBitChecked)
            break;
        }
        continue;
      }
     

      if (message.auto_generated) {
        message.waitClass = data.messages[i - 1].waitClass;
        continue;
      }

      message.waitClass = "uuuuhhhhhhh....";

    }

    return data;
  }
});
</script>
</dom-module>
